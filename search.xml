<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在windows下用nvm 安装node]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2Fnvm%2Fnode%2F%E5%9C%A8windows%E4%B8%8B%E7%94%A8nvm-%E5%AE%89%E8%A3%85node%2F</url>
    <content type="text"><![CDATA[注：现在node的新版本已默认安装了npm 1. nvm 下载 nvm 的下载地址：https://github.com/coreybutler/nvm-windows/releases 。选择第一个 nvm-noinstall.zip ，然后解压在系统盘（一般开发相关的文件我都放C盘，但是放别的盘也是可以的）。我放的目录路径是C:\dev\nvm。解压出来的文件有： elevate.cmd elevate.vbs install.cmd LICENSE nvm.exe 2. nvm 安装 双击 install.cmd ，是以控制台形式显示的，第一下直接按回车，然后会在C盘根目录产生settings.txt，把这个文件放进刚刚解压的那个目录，然后修改settings.txt内容，改成下面那样： 123456root: C:\dev\nvmpath: C:\dev\nodejs arch: 64proxy: none node_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ 但是有些人很不幸，这个方法行不通，因为打开 install.cmd按下回车后，显示拒绝访问注册表路径，并弹出一个settings.txt。这时候，你只要淡定地叉掉那个文本以及控制台，然后在刚刚的目录里新建一个文件settings.txt，最后把上面的内容复制进去就可以了。 root ： nvm的存放地址 path ： 存放指向node版本的快捷方式，使用nvm的过程中会自动生成。一般写的时候与nvm同级。 arch ： 电脑系统是64位就写64,32位就写32 proxy ： 代理 3. nvm 配置 以控制台方法执行成功的，在环境变量里会自动配置了 NVM_HOME 和 NVM_SYMLINK ，这时候只要修改相应的路径就行了。 直接创建settings文件的可以在环境变量里创建 NVM_HOME 和 NVM_SYMLINK，并添加路径 要是嫌弃可视化界面打开环境变量的步骤太麻烦，可以直接使用 windows+r =&gt; sysdm.cpl 12NVM_HOME： C:\dev\nvmNVM_SYMLINK ： C:\dev\nodejs 在PATH里加上;%NVM_HOME%;%NVM_SYMLINK%;。 一键控制台install的还要检查 环境变量 PATH 上的路径有没有添加C:\dev\nvm以及C:\dev\nodejs,有的话就删掉。 4. 检测安装结果 打开控制台，输入：nvm -v,若是出现版本信息，则安装。若报错，那就重新把步骤再捋一遍。 检查环境变量是否配置成功：可以在控制台输入：set [环境变量名]，查看路径是否填写错误 5. 使用node 控制台下载 =&gt; 输入：nvm install [版本号]，下载最新版的可以直接输nvm install latest 下载完成后，在控制台输入：nvm use [版本号]。即使用这个版本号的node了。在use后，上面所说的nodejs文件夹就自动生成了。（在use之前是没有的哦）]]></content>
      <categories>
        <category>前端</category>
        <category>nvm</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 二]]></title>
    <url>%2FJava%2FSpring-Boot%2FSpring-Boot-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[一、搭建基本环境1、导入数据库文件 创建出department和employee表 2、创建JavaBean封装数据 3、整合mybatis操作数据库 1、配置数据源信息 2、使用注解版的Mybatis 1）、@MapperScan指定需要扫描的mapper接口所在的包 二、快速体验缓存12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 步骤： 1、开启基于注解的缓存 @EnableCaching 2、标注缓存注解即可 @Cacheable 将方法的运行结果进行缓存，以后再要相同的数据，直接从缓存中获取，不在调用方法 CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一的名字； 几个属性： cacheNames/value: 指定缓存组件的名字 key：缓存数据使用的key，可以用它指定，默认是使用方法参数的值 1-方法返回值 编写SpEL：#id：参数id的值 #a0 #p0 #root.args[0] @Cacheable(cacheName = &quot;emp&quot;, key=&quot;#id&quot;) keyGenerator: key的生成器；也可以自己指定key的生成器的组件id key/keyGenerator：二选一使用 cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 condition：指定符合条件的情况下才缓存； 例： @Cacheable(cacheName = &quot;emp&quot;, condition=&quot;#id&gt;0&quot;) unless: 否定缓存，当unless指定的条件为true，方法的返回值就不会被缓存；可以获取的结果进行判断 sync：是否使用异步模式 原理： 1、自动配置类：CacheAutoConfiguration 2、缓存的配置类 3、哪个配置类默认生效：Simple 4、给容器中注册了一个CacheManager，ConcurrentMapCacheManager 5、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中； 运行流程： @Cacheable： 1、方法运行之前，先去查询Cache（缓存组件），按照cacheName指定的名字获取； （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数 @CacheEvict 清除缓存 key：指定要清除的数据· allEntries = true 指定清除这个缓存中所以的数据 beforeInvocation = false；缓存的清除是否在方法之前执行，默认代表缓存清除操作是在方法执行之后执行；如果出现异常不会清除、 @CachePut： 既调用方法，又更新缓存数据；同步更新缓存 修改了数据库的某个数据，同时更新缓存 key：指定要更新的数据 @Caching( //定义复杂缓存规则 cacheable = &#123; @Cacheable(value=&quot;emp&quot;, key=&quot;#lastName&quot;) &#125;, put = &#123; @CachePut(value=&quot;emp&quot;, key=&quot;#result.id&quot;), @CachePut(value=&quot;emp&quot;, key=&quot;#result.email&quot;) &#125; ) @CacheConfig(cacheName=&quot;emp&quot;) //注在类上,抽取缓存的公共配置 三、整合redis作为缓存Redis是一个开源（BSD许可）的，内存中的数据结构储存系统，它可以用作数据库、缓存和消息中间件。 1、安装redis，使用docker； 12345docker images 查看docker pull registry.docker-cn.com/library/redis docker下载redis镜像docker run -d -p 6376:6379 --name myredis + 镜像名 说明： -d：后台启动；-p：暴露端口；6379映射 到6379；重命名的镜像名myredis 2、引入redis的starter； 3、配置redis 123456789101112131415161718192021222324252627282930313233343536@AutowiredStringRedisTemplate stringRedisTemplate; //操作k-v都是字符串的@AutowiredRedisTemplate redisTemplate; //k-v都是对象的 Redis常见的五大数据类型 * String（字符串）、List（列表）、Set（集合）、Hash（散列）、ZSet（有序集合） * stringRedisTemplate.opsForValue() [String（字符串）] * stringRedisTemplate.opsForList() [List（列表）] * stringRedisTemplate.opsForSet() [Set（集合）] * stringRedisTemplate.opsForHash() [Hash（散列）] * stringRedisTemplate.opsForZSet() [ZSet（有序集合）]//给redis中保存数据stringRedisTemplate.opsForValue().append(&quot;mgs&quot;, &quot;hello&quot;);//从redis读数据String msg = stringRedisTemplate.opsForValue().get(&quot;msg&quot;);System.out.println(msg);stringRedisTemplate.opsForList().leftPush(&quot;mylist&quot;, &quot;1&quot;);stringRedisTemplate.opsForList().leftPush(&quot;mylist&quot;, &quot;2&quot;);//测试保存对象@AutowiredRedisTemplate&lt;Object, Employee&gt; EmpRedisTemplate; //自定义config序列化对象 Employee employee = new Employee(); //默认如果保存对象，使用序列化机制，序列化后的数据保存到redis中 //redisTemplate.opsForValue().set(&quot;emp-01&quot;, employee); /** * 1、将数据以json的方式保存 （1）、自己将对象转为json （2）、redisTemplate默认的序列化规则;改变默认的序列化规则 */ EmpRedisTemplate.opsForValue().set(&quot;emp-01&quot;, employee); 自定义RedisConfig 123456789101112131415@Configurationpublic class redisConfig &#123; @Bean public RedisTemplate&lt;Object, Employee&gt; redisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException&#123; RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); //序列化器 Jackson2JsonRedisSerializer&lt;Employee&gt; serializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(serializer); return template; &#125;&#125; 4、测试缓存 123456789101112131415原理：CacheManager===Cache 缓存组件来实际给缓存中存取数据1）、引入redis的starter，容器中保存的是RedisCacheManager；2）、RedisCacheManager 帮我们创建RedisCache 来作为缓存组件；RedisCache 通过操作redis缓存数据3）、默认保存数据 k-v 都是object；利用序列化保存；如何保存json 1、引入了redis的starter，cacheManager变为RedisCacheManager； 2、默认创建的 RedisCacheManager 操作redis的时候使用的是 RedisTemplate&lt;Object, Object&gt; 3、RedisTemplate&lt;Object, Object&gt; 是默认使用jdk的序列化机制4）、自定义cacheManager 四、rabbitmq1、安装rabbitmq，使用docker； 12345docker images 查看docker pull registry.docker-cn.com/library/rabbitmq: 3-management docker下载redis镜像docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq + 镜像名 说明： -d：后台启动；-p：暴露端口；5672映射到5672；15672映射到15672；重命名的镜像名myrabbitmq 2、引入redis的starter； 3、配置redis 12345678910111213自动配置1、RabbitAutoConfiguration；2、有自动配置了连接工厂ConnectionFactory；3、RabbitProperties封装了 RabbitMq的配置4、RabbitTemplate：给RabbitMQ发送和接收消息5、AmqpAdmin：RabbitMQ系统管理功能组件6、@EnableRabbit + @RabbitListener 监听消息队列内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Autowired RabbitTemplate rabbitTemplate; @Autowired AmqpAdmin amqpAdmin; @Test public void createExchange() &#123; //amqpAdmin.declareExchange(new DirectExchange(&quot;amqpadmin.exchange&quot;)); //System.out.println(&quot;创建完成&quot;); amqpAdmin.declareQueue(new Queue(&quot;amqpadmin.queue&quot;, true)); //创建绑定规则 amqpAdmin.declareBinding(new Binding(&quot;amqpadmin.queue&quot;, Binding.DestinationType.QUEUE, &quot;amqpadmin.exchange&quot;, &quot;amqp.name&quot;, null)); &#125; /** * 1、单播（点对点） */ @Test public void contextLoads() &#123; //Message需要自己构造一个，定义消息体内容和消息头 //rabbitTemplate.send(exchage, routeKey, message); //object默认当成消息体，只需要传入要发送的对象，自动序列化发送给rabbitmq； //rabbitTemplate.convertAndSend(exchage, routeKey, object); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;, &quot;这是一个消息&quot;); map.put(&quot;data&quot;, Arrays.asList(&quot;helloWorld&quot;, 123, true)); //对象被默认序列化以后发送出去 //rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;, &quot;example.news&quot;, map); rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;, &quot;example.news&quot;, new Book(&quot;西游记&quot;, &quot;吴承恩&quot;)); &#125; //接收数据，如何将数据自动转为json发送出去 @Test public void receive() &#123; Object o = rabbitTemplate.receiveAndConvert(&quot;exchange.direct&quot;); System.out.println(o.getClass()); System.out.println(o); &#125; /** * 广播 */ public void sendMSg() &#123; rabbitTemplate.convertAndSend(&quot;exchange.fanout&quot;, &quot;&quot;, new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;)); &#125; config 12345678@Configurationpublic class MyAMQPConfig &#123; @Bean public MessageConverter messageConverter() &#123; return new Jackson2JsonMessageConverter(); &#125;&#125; 五、检索1、安装ElasticSearch，使用docker； 12345docker images 查看docker pull registry.docker-cn.com/library/elasticsearch docker下载redis镜像docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xms256m&quot; -d -p 9200:9200 -p9300:9300 --name ES01 + 镜像名 说明： -e：限制内存使用；-d：后台启动；-p：暴露端口；9200映射到9200；9300 映射到9300 ；重命名的镜像名ES01 2、引入ElasticSearch的starter； 3、配置ElasticSearch 12345SpringBoot 默认支持两种技术来和ES交互 1、Jest（默认不生效） 需要导入jest的工具包（ io.searchbox.client.JestClient） 123456&lt;!-- https://mvnrepository.com/artifact/io.searchbox/jest --&gt; &lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt; &lt;/dependency&gt; 123456789101112132、SpringData ElasticSearch【ES版本有可能不合适】 [版本适配说明](https://github.com/spring-projects/spring-data-elasticsearch) 如果版本不适配： 1）、升级springboot 版本 2）、安装对应版本的ES 1）、Client 节点信息clusterNodes、clusterName 2）、ElasticsearchTemplate 操作Es 123456789101112131415161718192021222324252627282930313233343536373839@Autowired JestClient jestClient; @Test public void contextLoads() &#123; //1、给Es中索引（保存）一个文档 Article article = new Article(); article.setId(1); article.setTitle(&quot;好消息&quot;); article.setAuthor(&quot;zhangsan&quot;); article.setContent(&quot;Hello World!&quot;); //构建一个索引功能 Index index = new Index.Builder(article).index(&quot;atguigu&quot;).type(&quot;news&quot;).build(); try &#123; //执行 jestClient.execute(index); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //测试搜索 @Test public void search() &#123; String json = &quot;&quot;; //构建搜索功能 Search search = new Search.Builder(json).addIndex(&quot;atguigu&quot;).addType(&quot;news&quot;).build(); //执行 try &#123; SearchResult result = jestClient.execute(search); System.out.println(result.getJsonString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 参考文档 六、任务1、异步任务 在主方法上加@EnableAsync //开启异步注解功能 1234567@EnableAsync //开启异步注解功能@SpringBootApplicationpublic class Springboot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04TaskApplication.class, args); &#125;&#125; 方法上加@Async //告诉spring这是个异步方法 123456789101112@Servicepublic class AsyncService &#123; @Async //告诉spring这是个异步方法 public void hello() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;处理数据中...&quot;); &#125;&#125; 2、定时任务 在主方法开启定时任务@EnableScheduling //开启基于注解的定时任务 1234567@EnableScheduling //开启基于注解的定时任务@SpringBootApplicationpublic class Springboot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04TaskApplication.class, args); &#125;&#125; 在方法上使用 1234567891011121314151617181920@Servicepublic class ScheduledService &#123; /** * second(秒)、minute（分）、hour（时）、day of month（日）、month（月）、day of week（周几） * 0 * * * * MON-FRI * 【0 0/5 14，18 * * ？】 每天14点整，和18点整，每隔5秒执行一次 * 【0 15 10 ？ * 1-6】 每个月的周一到周六10：15分执行一次 * 【0 0 2 ？ * 6L】 每个月的最后一个周六凌晨2点执行一次 * 【0 0 2 LW * ？】 每个月的最后一个工作日凌晨2点执行一次 * 【0 0 2-4 ？ * 1#1】 每个月的第一个周一凌晨2点到4点期间，每个整点执行一次 */ //@Scheduled(cron = &quot;0 * * * * MON-SAT&quot;) //@Scheduled(cron = &quot;0,1,2,3,4 * * * * MON-SAT&quot;) //枚举 //@Scheduled(cron = &quot;0-4 * * * * MON-SAT&quot;) @Scheduled(cron = &quot;0/4 * * * * MON-SAT&quot;) //梅4秒执行一次 public void hello() &#123; System.out.println(&quot;hello...&quot;); &#125;&#125; 3、邮件任务 引入starter依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 配置文件application.properties 1234spring.mail.username=jaunelau@qq.comspring.mail.password=aaaaa #授权码spring.mail.host=smtp.qq.comspring.mail.properties.mail.smtp.ssl.enable=true # 开启ssl 测试 1234567891011121314151617181920212223242526272829303132@Autowired JavaMailSenderImpl mailSender; @Test public void contextLoads() &#123; SimpleMailMessage mailMessage = new SimpleMailMessage(); //邮件设置 mailMessage.setSubject(&quot;通知今晚开户&quot;); mailMessage.setText(&quot;今晚7：30开会&quot;); mailMessage.setTo(&quot;123@qq.com&quot;); mailMessage.setFrom(&quot;456@qq.com&quot;); mailSender.send(mailMessage); &#125; @Test public void test02() throws MessagingException &#123; //1、创建一个复杂的消息邮件 MimeMessage mailMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mailMessage, true); //邮件设置 helper.setSubject(&quot;通知今晚开户&quot;); helper.setText(&quot;&lt;b&gt;今晚7：30开会&lt;/b&gt;&quot;, true); helper.setTo(&quot;123@qq.com&quot;); helper.setFrom(&quot;456@qq.com&quot;); //上传文件 helper.addAttachment(&quot;1.jpg&quot;, new File(&quot;c:\\图片&quot;)); helper.addAttachment(&quot;2.jpg&quot;, new File(&quot;&quot;)); mailSender.send(mailMessage); &#125; 七、安全SpringSecurity 1、引入SpringSecurity； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 2、编写SpringSecurity的配置类； 123@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; 3、控制请求的访问权限； Ctrl+O打开可重写的方法 修改引入 12345&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt; &lt;/dependency&gt; config配置 12345678910111213141516171819202122232425262728293031323334353637383940414243@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); //定制请求的授权规则 http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;); //开启自动配置的登陆功能；效果：如果没有登陆，没有权限就会来到登陆页面 http.formLogin().usernameParameter(&quot;user&quot;).passwordParameter(&quot;password&quot;) .loginPage(&quot;/userlogin&quot;); //1、/login来到登陆页 //2、重定向到/login？error表示登陆失败 //3、更多详细规则 //4、默认post形式的/login代表处理登陆 //5、一旦定制LoginPage；那么LoginPage的post请求就是登陆 //开启自动配置的注销功能 http.logout().logoutSuccessUrl(&quot;/&quot;); //注销成功以后来到首页 //1、访问/logout 表示用户注销，清空session //2、注销成功会返回 /login?logout 页面 //开启记住我功能 http.rememberMe().rememberMeParameter(&quot;remember&quot;); //登陆成功后，将cookie发给浏览器保存，以后访问页面带上这个cookie，只要通过检查就可以免登陆 //点击注销会删除cookie &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication() .withUser(&quot;zhangsan&quot;).password(&quot;123456&quot;).roles(&quot;VIP1&quot;, &quot;VIP2&quot;) .and() .withUser(&quot;lisi&quot;).password(&quot;123456&quot;).roles(&quot;VIP2&quot;, &quot;VIP3&quot;) .and() .withUser(&quot;wangwu&quot;).password(&quot;123456&quot;).roles(&quot;VIP1&quot;, &quot;VIP3&quot;); &#125; 页面templates/index.html 123456&lt;form th:action=&quot;@&#123;/userlogin&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input name=&quot;user&quot;&gt;&lt;br&gt; 密码：&lt;input name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; /&gt; &lt;/form&gt; 八、分布式1、dubbo和zookeeper1）、安装zookeeper，使用docker； 123docker images 查看docker pull registry.docker-cn.com/library/zookeeper docker下载redis镜像 1$ docker run --name some-zookeeper -p 2181:2181 --restart always -d zookeeper +镜像名 1[参考](https://hub.docker.com/_/zookeeper/) 2）、引入依赖(两个项目都引用) 12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入zookeeper的客户端工具--&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; provider-ticket项目 12341、将服务提供者注册到注册中心* 1、引入dubbo和zkclient相关依赖* 2、配置dubbo的扫描包和注册中心地址* 3、使用@Service发布服务 接口 1234public interface TicketService &#123; public String getTicket();&#125; 接口的实现 12345678910import com.alibaba.dubbo.config.annotation.Service;@Component //注册为组件@Service //将服务发布出去，注意service的引用dubbopublic class TicketServiceImpl implements TicketService &#123; @Override public String getTicket() &#123; return &quot;《厉害了，我的国》&quot;; &#125;&#125; 配置文件 12345dubbo.application.name=provider-ticketdubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.scan.base-packages=com.example.ticket.service consumer-user项目 应用依赖； 创建和provider-ticket项目相同路径的service接口 1234public interface TicketService &#123; public String getTicket();&#125; 自己的service 123456789101112@Servicepublic class UserService &#123; @Reference //引用它的实现 TicketService ticketService; public void hello() &#123; String ticket = ticketService.getTicket(); System.out.println(&quot;买到票了：&quot; + ticket); &#125;&#125; 配置文件 123dubbo.application.name=consumer-userdubbo.registry.address=zookeeper://127.0.0.1:2181 测试 1234567@Autowired UserService userService; @Test public void contextLoads() &#123; userService.hello(); &#125; 2、Spring Boot和Spring Cloud 1、新建eureka-server项目，选择Cloud Discovery-&gt;Eureka Server 配置文件application.yml 12345678910server: port: 8761eureka: instance: hostname: eureka-server # eureka 实例的主机名 client: register-with-eureka: false # 不把自己注册到eureka上 fetch-registry: false # 不从eureka上来获取服务的注册信息 service-url: defaultZone: http://localhost:8761/eureka/ # 注册中心服务注册的地址 主程序 12345678910111213/*** 注册中心* 1、配置eureka信息* 2、主程序上加上@EnableEurekaServer注解*/@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 2、新建provider-ticket项目，选择Cloud Discovery-&gt;Eureka Discovery 配置文件application.yml 123456789101112server: port: 8001spring: application: name: provider-ticketeureka: instance: prefer-ip-address: true # 注册服务的时候使用服务的ip地址 client: service-url: defaultZone: http://localhost:8761/eureka/ # 注册中心服务注册的地址 service 12345678@Servicepublic class TicketService &#123; public String getTicket() &#123; System.out.println(&quot;8001&quot;); return &quot;《厉害了，我的国》&quot;; &#125;&#125; controller 1234567891011@RestControllerpublic class TicketController &#123; @Autowired TicketService ticketService; @GetMapping(&quot;/ticket&quot;) public String getTicket() &#123; return ticketService.getTicket(); &#125;&#125; 3、新建consumer-user项目，选择Cloud Discovery-&gt;Eureka Discovery 配置文件application.yml 123456789101112spring: application: name: consumer-userserver: port: 8200eureka: instance: prefer-ip-address: true # 注册服务的时候使用服务的ip地址 client: service-url: defaultZone: http://localhost:8761/eureka/ # 注册中心服务注册的地址 controller 123456789101112@RestControllerpublic class UserController &#123; @Autowired RestTemplate restTemplate; @GetMapping(&quot;buy&quot;) public String buyTicket(String name) &#123; String forObject = restTemplate.getForObject(&quot;http://PROVIDER-TICKET/ticket&quot;, String.class); return name + &quot;购买了&quot; + forObject; &#125;&#125; 主程序 1234567891011121314@EnableDiscoveryClient //开启发现注册功能@SpringBootApplicationpublic class ConsumerUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerUserApplication.class, args); &#125; @LoadBalanced //使用负载均衡机制 @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 1项目：springboot-06-springcloud 九、Spring Boot 与 开发热部署引入Developer tools依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; Ctrl + F9（Build Product）：重新编译 十、监控管理步骤： 1、引入spring-boot-starter-actuator依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 2、通过http方式访问监控端点 3、可进行shutdown（POST提交，此端点默认关闭） 将源码托管给gitHup，GitProperties配置类它继承了InfoProperties里面的属性都能用 git.properties配置文件 123git.branch=mastergit.commit.id=xjkd33sgit.commit.time=2017-12-12 12:12:56 浏览器访问：http://localhost:8080/info 可以查看信息 application.properties配置文件 12345678910111213141516171819202122232425262728293031management.security.enabled=falseinfo.app.id=helloinfo..app.version=1.0.0# endpoints.metrics.enabled=false# 修改端点名beans-&gt; myBeanendpoints.beans.id=myBeanendpoints.beans.path=/bean# 关闭端点# endpoints.beans.enabled=false# 修改端点名endpoints.dump.path=/du# 关闭所有的端点访问endpoints.enabled=false# 只启用beansendpoints.beans.enabled=true# 定制端点访问根路径management.context-path=/manage# 关闭http端点# management.port=-1# 修改端点management.port=8181# http://localhost:8080/health 在浏览器访问返回建康状态# spring.redis.host=localhost 自定义建康状态指示器 1、编写一个指示器 实现HealthIndicator 接口 2、指示器的名字 xxxHealthIndicator 3、加入容器中 123456789@Componentpublic class myAppHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; //自定义的检查方法 //Health.up().build() 代表建康 return Health.down().withDetail(&quot;msg&quot;, &quot;服务异常&quot;).build(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 一]]></title>
    <url>%2FJava%2FSpring-Boot%2FSpring-Boot-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、Spring Boot 入门1、spring boot 简介 简化spring应用开发的一个框架 整个spring技术栈的一个大整合 J2EE开发的一站式解决方案 2、微服务Microservices2014 martln fowler 微服务: 架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 给一个功能元素最终都是一个可独立替换和独立升级的软件单元 微服务文档 3、环境准备4、spring boot Hello World一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello world字符串； 1、创建一个maven工程：（jar）2、导入依赖spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序：启动spring boot应用12345678910/*** @SpringBootApplication 来标注一个主程序，说明这是一个spring boot应用*/@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; //spring 应用启动起来 SpringApplication.run(HelloWorldMainApplication.class, args); &#125;&#125; 4、编写相关的controller、service12345678@Controllerpublic class HelloController &#123; @ResponseBody //写给浏览器 @RequestMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;Hello World!&quot;; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!--这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用Java -jar 的命令进行执行； 5、探究1、pom文件1、父项目12345678910111213&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理spring boot 应用里面的所有依赖版本； spring boot 的版本仲裁中心； 以后我们导入的依赖默认是不需要写版本的；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web:spring-boot-starter:spring-boot场景启动器：帮我们导入的web模块正常运行所依赖的组建； spring boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只要在项目里面引用这些starter相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景启动器 2、主程序类，主入口类12345678910/*** @SpringBootApplication 来标注一个主程序，说明这是一个spring boot应用*/@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; //spring 应用启动起来 SpringApplication.run(HelloWorldMainApplication.class, args); &#125;&#125; @SpringBootApplication:spring boot应用标注在某个类上说明这个类是用spring boot的主配置类，Spring Boot就应该运行这个类的main方法来启动spring boot应用； 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration: spring boot配置类； 12345标注在某个类上，说明这是一个spring boot的配置类；**@Configuration**：配置类上来标注这个注解； 配置类------配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能： 1以前我们需要配置的东西，spring boot帮我们自动配置；**@EnableAutoConfiguration**告诉spring boot开启自动配置功能；这样自动配置才能生效 123@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage: 自动配置包 12345678910111213@**Import**(&#123;AutoConfigurationImportSelector.class&#125;)；spring的底层注解@import，给容器中导入一个组件；导入的组件由AutoConfigurationImportSelector.class；将主配置类（@SpringBootApplication标注的类）的是所在包下面所有子包里面的所有组件扫描到spring容器；@**Import**(&#123;EnableAutoConfigurationImportSelector.class&#125;)； 给容器中导入组件？ **EnableAutoConfigurationImportSelector**：导入那些组件的选择器； 将所需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）：就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，就免去了我们手动编写配置注入功能组件等工作； 12SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, classLoader);spring boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguraton指定的值； 将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整合解决方案和自动配置都在：spring-boot-autoconfigure-1.5.9.RELEASE.jar; 6、使用spring Initializer快速创建spring boot项目IDE都支持使用spring的项目创建向导快速创建一个spring boot项目； 选择我们需要的模块；向导会联网创建spring boot项目； 默认生成的spring boot项目： 主程序已经生成好了，我们只需要写我们自己的逻辑； resources文件夹中目录结构 static：保存所有的静态资源；js、css、images； templates：保存所有的模板页面；（spring boot默认jar包并使用嵌入式的tomcat，默认不支持jsp页面）；可以使用模板引擎（freemarker、thymeleaf）； applicaton.properties: spring boot应用的配置文件；可以修改一些默认配置； 二、配置文件1、配置文件spring boot使用一个全局的配置文件，配置文件名是固定的； application.properties application.yml 配置文件的作用：修改spring boot自动配置的默认值；spring boot在底层都给我们自动配置好了； YAML（YAML AIn‘t Markup Language） 123YAML A Markup Language：是一个标记语言YAML Isn&apos;t Markup Language: 不是一个标记语言； 标记语言： 12345以前的配置文件：大多都使用的是xxxx.xml文件；YAML：以数据为中心，比json、xml等更合适做配置文件；YAML：配置例子 12server port: 8081 1XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法1、基本语法k(:空格) v：表示一对键值对（空格必须有）； 以空格的宿进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面值：普通的值（数字、字符串、布尔）： k: v : 字面直接来写； 123456789字符串默认不加上单引号或者双引号；“”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name：“zhangsan \n lisi”: 输出：zhangsan 换行 lisi’‘：单引号；会转义特殊字符串，特殊字符最终只是一个普通的字符串数量 name：’zhangsan \n lisi‘; 输出：zhangsan \n lisi 对象、Map（属性和值）（键值对）： 123k: v : 在下一行来写对象的属性和值的关系；注意缩进 对象还是k: v的方式 123friends： lastName：zhangsan age：20 行内写法： 1friends: &#123;laseName: zhangsan,age: 20&#125; 数组（List、Set）: 用- 值表示数组中的一个元素 1234pets:- cat- dog- pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件： 123456789101112person: lastName: hello age: 19 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: v2&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2 javaBean： 123456789101112131415161718/*** 将配置文件中配置的每一个属性的值，映射到这个组件中* @ConfigurationProperties：告诉spring boot将本类中的所有属性和配置文件中相关的配置进行绑定； prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射* 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能；* @ConfigurationProperties(prefix = &quot;person&quot;) 默认从全局配置文件中获取值*/@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中属性 松散绑定（松散语法） 支持 SpEL 不支持 JSR303数据校验 支持 复杂类型封装 支持 配置文件yml还是properties他们都能获取值； 如果说，我们只要在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value 如果说，我们专门编写一个JavaBean来和配置文件 进行映射，我们就直接使用@ConfigurationProperties 3、配置文件注入值校验12345678910111213141516171819202122@Component@ConfigurationProperties(prefix = &quot;person&quot;)@Validatedpublic class Person &#123; /** * &lt;bean class=&quot;Person&quot;&gt; * &lt;property name=&quot;lastName&quot; value=&quot;字面值/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt; * &lt;/bean&gt; */ @Email //@Value(&quot;$&#123;person.last-name&#125;&quot;) private String lastName; //@Value(&quot;#&#123;11*2&#125;&quot;) private Integer age; //@Value(&quot;true&quot;) private Boolean boss; private Date birth; private Map&lt;String,, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 4、@PropertySource&amp;@ImportResource@PropertySource: 加载指定的配置文件； 12345678910111213141516171819202122232425262728/*** 将配置文件中配置的每一个属性的值，映射到这个组件中* @ConfigurationProperties：告诉spring boot将本类中的所有属性和配置文件中相关的配置进行绑定； prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射* 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能；* @ConfigurationProperties(prefix = &quot;person&quot;) 默认从全局配置文件中获取值*/@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; /** * &lt;bean class=&quot;Person&quot;&gt; * &lt;property name=&quot;lastName&quot; value=&quot;字面值/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt; * &lt;/bean&gt; */ @Email //@Value(&quot;$&#123;person.last-name&#125;&quot;) private String lastName; //@Value(&quot;#&#123;11*2&#125;&quot;) private Integer age; //@Value(&quot;true&quot;) private Boolean boss; private Date birth; private Map&lt;String,, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; @ImportResource：导入spring的配置文件，让配置文件里面的内容生效； spring boot里面没有spring的配置文件，我们自己编辑的配置文件，也不能自动识别； 想让spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;&quot;classpath:beans.xml&quot;&#125;)导入spring的配置文件让其生效 不来编写spring的配置文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;helloService&quot; class=&quot;com.ousacn.service.HelloService&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; spring boot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类======spring配置文件 2、使用@Bean给容器中添加组件 1234567891011121314/*** @Configuration: 指明当前类是一个配置类；就是来替代之前的spring配置文件** 在配置文件中使用&lt;bean&gt;&lt;/bean&gt;标签添加组件*/@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这组件默认的id就是方法名 @Bean public HelloService helloService() &#123; System.out.println(&quot;配置文件@Bean给容器中添加组件了...&quot;); return new HelloService(); &#125;&#125; @Configuration、@Bean都是spring的注解 4、配置文件占位符1、随机数1234$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125;$&#123;random.uuid&#125; 2、占位符获取之前配置的值，如果没有可以使用:指定默认值123person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.dog.name=$&#123;person.hello:hello&#125;_dog 5、profile1、多个profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认是使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617server: port: 8081spring: profiles: active: dev--- #划分文档块server: port: 8082spring: profiles: dev---server: port: 8083spring: profiles: prod #指定属于哪个环境 3、激活指定profile1、在配置文件中指定 spring.profiles.active=dev 2、命令行： 1234567java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev;可以直接在测试的时候，配置传入命令行参数在Run/Debug Configurations -&gt;Program arguments里--spring.profiles.active=dev 3、虚拟机参数 123在Run/Debug Configurations -&gt; VM options里： -Dspring.profiles.active=dev 6、配置文件加载位置spring boot 启动会扫描以下位置的application.properties或者application.yml文件作为spring boot的默认配置文件 -file:./config/ -file:./ -classpath:/config/ -classpath:/ -以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容 1`spring boot会从四个位置全部加载主配置文件；**互补配置**` 我们也可以通过配置spring.config.location来改变默认配置;项目打包好以后，我们可以使用命令行参数形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； 例：java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 配置文件中配置项目的访问路径(localhost:8080/boot02) 12# 配置项目的访问路径server.context-path=/boot02 7、外部配置加载顺序spring boot也可以从一下位置加载配置：按照优先级从高到低；高优先级覆盖低优先级配置，所有的配置会形成互补配置 1、命令行参数 123java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --server.port=8087 --server.context-path=/boot02多个配置用空格分开；--配置项=值 2、来自java:comp/env的JNDI属性 3、Java系统属性（System.getProperties()） 4、操作系统环境变量 5、RandomValuePropertySource配置的random.* 属性值 由jar包外向jar包内进行寻找 优先加载带profile 6、jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7、jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 在来加载不带profile 8、jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9、jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10、@Configuration注解类上的@PropertySource 11、通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源： 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理： 配置文件能配置的属性参照 自动配置 1）、spring boot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration 2）、@EnableAutoConfiguration作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以插件selectImports()方法的内容； 1List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 1获取候选的配置。 1SpringFactoriesLoader.loadFactoryNames 1扫描所有jar包类路径下的 META-INF/spring.factories 1把扫描到的这些文件的内容包装成properties对象 1从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 将类路径下 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加入到容器中； 1org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ 1org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\ 1org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\ 每一个这样的 xxxAutoConfiguration 类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4)、以HttpEncodingAutoConfiguration为例解释自动配置原理； 1234567891011121314151617181920212223@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(&#123;HttpEncodingProperties.class&#125;) //自动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来@ConditionalOnWebApplication( type = Type.SERVLET) //spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 作用：判断应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;) //判断当前项目有没有这个类CharacterEncodingFilter；springMVC中进行乱码解决的过滤器；@ConditionalOnProperty( prefix = &quot;spring.http.encoding&quot;, value = &#123;&quot;enabled&quot;&#125;, matchIfMissing = true) //判断配置文件中是否存在某个配置，spring.http.encoding.enabled;如果不存在，判断也是成立的//即使我们配置文件中不配置spring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每个属性又是和配置文件绑定的； 5)、所有在配置文件中能配置的属性都是在xxxProperties类中封装者；配置文件能配置什么就可以参照某个功能对应的这个属性类是否生效？ 1234@ConfigurationProperties( prefix = &quot;spring.http.encoding&quot;) //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; 1、精髓：1）、Spring boot启动会加载大量的自动配置类 2）、我们看我们需要的功能有没有spring boot默认写好的自动配置类； 3）、我们在来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要在来配置了） 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxAutoConfiguration：自动配置类； 给容器中添加组件 xxxProperties：封装配置文件中相关属性；]]></content>
      <categories>
        <category>Java</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo + github + nexT 创建博客]]></title>
    <url>%2Fhexo%2Fhexo-github-%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[准备工作 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd运行npm install -g hexo（要翻墙） 本地搭建hexo静态博客 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙） 生成完模板，运行npm install 最后运行：hexo server（运行程序，访问本地localhost:4000可以看到博客已经搭建成功） 说明：如果npm install -g hexo 出现npm ERR! code Z_BUF_ERROR，出现这种问题是npm的缓存问题 npm cache clean –force 将博客与Github关联 在Github上创建名字为XXX.github.io的项目（必须是public），XXX为自己的github用户名。 打开本地的MyBlog文件夹项目内的_config.yml配置文件，将其中的type设置为git 1234deploy: type: git repository: https://github.com/ouscan/ouscan.github.io.git branch: master 运行：npm install hexo-deployer-git –save 运行：hexo g（本地生成静态文件） 运行：hexo d（将本地静态文件推送至Github） 此时，打开浏览器，访问http://ouscan.github.io 绑定域名 打开cmd， ping ouscan.github.io 获取到获取发布在github上的page页面的服务地址（例如：192.30.252.156） 域名提供商设置 解析：1）添加一条A记录：@ -&gt; 192.30.252.156 ​ 2) 添加一条CNAME记录：CNAME -&gt; ouscan.github.io 博客添加CNAME文件 配置完域名后，进去博客目录，在source目录下新建CNAME文件，写入域名，如：www.ouscan.com 运行：hexo clean 运行：hexo g 运行：hexo d 跟新文章​ 至此博客已经基本搭建完成。 在MyBlog目录下执行：hexo new “我的第一篇文章”，会在source-&gt;_posts文件夹内生成一个.md文件。 编辑该文件（遵循Markdown规则） 修改起始字段 title 文章的标题 date 创建日期 （文件的创建日期 ） updated 修改日期 （ 文件的修改日期） comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字（文件名） 编写正文内容（MakeDown） hexo clean 删除本地静态文件（Public目录），可不执行。 hexo g 生成本地静态文件（Public目录） hexo deploy 将本地静态文件推送至github（hexo d） 添加菜单进入theme目录，编辑_config_yml文件，找到menu:字段，在该字段下添加一个字段。 1234menu: home: / about: /about ...... 然后找到lanhuages目录，编辑zh-Hans.yml文件： 1234menu: home: 首页 about: 关于作者 ...... 更新页面显示的中文字符，最后进入theme目录下的Source目录，新增一个about目录，里面写一个index.html文件。 文章内插入图片在文章中写入: 1![](/upload_image/1.jpg) 然后进入themes-主题名-source-upload_image目录下(自己创建)，将图片放到这个目录下，就可以了。 说明：当执行hexo g命令时，会自动把图片复制到 public文件的upload_image目录下。 个性化设置基本信息 在根目录下的_config.yml文件中，可以修改标题，作者等信息。打开编辑该文件，注意：每一个值的冒号后面都有一个半角空格！ 未生效的写法：title:nMask的博客 能生效的写法：title:[空格]nMask的博客 主题访问主题列表，获取主题代码。 进入themes目录，进入以下操作： 下载主题 (以next主题为例) 1git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开__config.yml文件，将themes修改为next（下载到的主题文件夹的名字） hexo g hexo d 关于hexo-next主题下的一些个性化配置，参考：Next主题配置 主题美化文章中添加居中模块文章Markdown中填写如下： 1&lt;blockquote class=&quot;blockquote-center&quot;&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 在文章底部增加版权信息在目录 next/layout/_macro/下添加 my-copyright.swig： 1234567891011121314151617181920212223242526272829303132&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css&quot;&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); clipboard.on(&apos;success&apos;, $(function()&#123; $(&quot;.fa-clipboard&quot;).click(function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import &quot;my-post-copyright&quot; 如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: date: tags: categories: copyright: true--- 自定义hexo new生成md文件的选项在/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。 123456789101112&lt;!--&lt;div class=&quot;powered-by&quot;&gt; &#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; rel=&quot;external nofollow&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&lt;/div&gt;&lt;div class=&quot;theme-info&quot;&gt; &#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; - &lt;a class=&quot;theme-link&quot; rel=&quot;external nofollow&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; NexT.&#123;&#123; theme.scheme &#125;&#125; &lt;/a&gt;&lt;/div&gt;--&gt; 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在meta标签后面插入这样一段代码： 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后文章中添加： 1password: nmask 如果password后面为空，则表示不用密码。 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如: 12345---......copyright: truetop: 100--- 默认不设置则为0，数值相同时按时间排序。 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: 12&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 添加热度next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig在”leancloud-visitors-count”&gt;标签后面添加℃。然后打开，/themes/next/languages/zh-Hans.yml，将visitors内容改为热度即可。 主页文章添加阴影效果打开\themes\next\source\css_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 鼠标点击小红心的设置将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 背景的设置将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面，标签之前 添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式： 12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 博文压缩在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在博客根目录下新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 增加阅读排行统计页面首先我们可以使用leancloud来统计页面阅读数量，以及储存这些信息，然后通过leancloud提供的api编写js脚本来获取阅读数量信息，并展示在页面上。首先新建一个page页面，hexo new page “”,然后编辑此.md文件，写下： 1234567891011121314151617181920212223242526&lt;script src=&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt;AV.initialize(&quot;&quot;, &quot;&quot;);&lt;/script&gt; //需要写上leancloud的key&lt;script type=&quot;text/javascript&quot;&gt; var time=0 var title=&quot;&quot; var url=&quot;&quot; var query = new AV.Query(&apos;Counter&apos;);//表名 query.notEqualTo(&apos;id&apos;,0); //id不为0的结果 query.descending(&apos;time&apos;); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) &#123; for (var i=0;i&lt;10;i++)&#123; var result=todo[i].attributes; time=result.time; //阅读次数 title=result.title; //文章标题 url=result.url; //文章url var content=&quot;&lt;p&gt;&quot;+&quot;&lt;font color=&apos;#0477ab&apos;&gt;&quot;+&quot;【阅读次数:&quot;+time+&quot;】&quot;+&quot;&lt;a href=&apos;&quot;+&quot;http://thief.one&quot;+url+&quot;&apos;&gt;&quot;+title+&quot;&lt;/font&gt;&quot;+&quot;&lt;/a&gt;&quot;+&quot;&lt;/p&gt;&quot;; // document.write(&quot;&lt;a href=&apos;&quot;+&quot;http://thief.one/&quot;+url+&quot;&apos;&gt;&quot;+title+&quot;&lt;/a&gt;&quot;+&quot; Readtimes:&quot;+time+&quot;&lt;br&gt;&quot;); document.getElementById(&quot;heheda&quot;).innerHTML+=content &#125; &#125;, function (error) &#123; console.log(&quot;error&quot;); &#125;);&lt;/script&gt; 设置favicon图标 选择一个favicon制作网站完成制作，例如：比特虫 ，制作一个1616，一个3232的； 两个不同尺寸大小的文件，重名为favicon-16x16-next.png和favicon-32x32-next.png； 将重命名的两个图片文件放到博客目录下的themes/next/source/images中（覆盖原来的两个默认的）如图所示： 添加头像 把想要设置的头像图片放到hexo/themes/next/source/images目录下; 在hexo/themes/next/layout/_macro目录中找到sidebar.swig文件; 在sidebar.swig文件中找到类名为：site-overview-wrap sidebar-panel sidebar-panel-active的section标签，进行如图所示的修改：效果如图所示：(若想去掉边框，可以根据头像标签的类名，全局搜索，找到对应的样式进行修改) 创建“分类”选项生成“分类”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 1$ hexo new page categories 成功后会提示： 1INFO Created: ~/Documents/blog/source/categories/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 文章分类date: 2017-05-27 13:47:40--- 添加type: &quot;categories&quot;到内容中，添加后是这样的： 12345---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot;--- 保存并关闭文件。 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 123456---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 创建“标签”选项生成“标签”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 1$ hexo new page tags 成功后会提示： 1INFO Created: ~/Documents/blog/source/tags/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 标签date: 2017-05-27 14:22:08--- 添加type: &quot;tags&quot;到内容中，添加后是这样的： 12345---title: 文章分类date: 2017-05-27 13:47:40type: &quot;tags&quot;--- 保存并关闭文件。 给文章添加“tags”属性打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- jQuery - 表格 - 表单验证就是这篇文章的标签了 12345678910---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端tags:- jQuery- 表格- 表单验证--- 至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 教程结束，赶紧去设置吧！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>nexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
